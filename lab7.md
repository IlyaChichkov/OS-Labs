
## Контрольные вопросы №7

### 1. Что такое драйвер устройства? Для чего он предназначен?

__Драйвер устройства – программа, предназначенная для управления внешним аппаратным устройством.__

Для правильного функционирования драйвера необходимо предоставить ему доступ к аппаратной части устройства. Это возможно сделать из пространства ядра ОС (kernel space). С этой стороны работа с аппаратным устройством выглядит как непосредственное обращение к его регистрам. Связь с пространством пользователя происходит посредством VFS.

### 2. Что такое модуль ядра? В чем отличие модуля ядра от драйвера?

__Модуль ядра — это скомпилированный код, который может быть загружен и выгружен в ядро по требованию.__

Другими словами, модуль – контейнер, в который можно поместить любой код, который требуется выполнить в привилегированном режиме, например код драйвера устройства.  

### 3. В чем отличие пользовательской программы от модуля Linux?

Хотя большинство малых и средних приложений выполняют от начала до конца одну задачу, каждый модуль ядра просто регистрирует себя для того, чтобы обслуживать в будущем запросы, не выполняя никаких задач, и его функция инициализации немедленно прекращается. 

### 4. Что такое символьное устройство? Привидите примеры. В чем отличие символьных от блочных устройств? 

__Символьное устройство – класс устройств, к которым возможно обращаться как к потоку байтов.__

Примерами подобных устройств являются текстовый экран (/dev/console), последовательные порты (/dev/tty0), принтер, сканер, клавиатура, мышь.  Главное отличие от блочных устройств, в том что в них обмен данными ведётся блоками. 

### 5. Что такое блочное устройство? Привидите примеры. В чем отличие сетевых от блочных устройств?

__Блочные устройства — периферийные устройства, обмен данными с которыми ведётся блоками (последовательностями байт), размер которых зависит от устройства.__

Для большинства устройств подобный размер блока равен 512 байтам. Т.к. работа производится с блоками, то считывание данных происходит быстрее, чем с использованием символьного устройства. Примером устройства, для работы с которым необходим блочный драйвер является жесткий диск. В операционной системе Linux он может быть обозначен, как /dev/ram0.

 Драйвер сетевого устройства похож на драйвер блочного устройства – обмен данными между ядром и сетевым устройством происходит путем передачи блоков данных, называемых сетевым пакетом. Однако, блочные драйверы работают, отвечая на запросы из ядра, тогда как сетевые драйверы получают пакеты извне.

### 6. Что такое сетевое устройство? Привидите примеры. В чем особенности работы с сетевыми устройствами?

__Сетевое устройство - устройство, отвечающее за работу компьютерной сети.__

Взаимодействие с ним ведется посредством сетевого драйвера. Данный класс драйверов несколько отличается от предыдущих двух – он не представлен в виде отдельного файла в структуре /dev и к нему не применимы стандартные операции чтения и записи. Несмотря на это, исторически сложилось, что данный класс также относят к драйверам.

### 7. Какими способами возможно выделить старший и младший номер устройства?

Назначить номера устройству возможно двумя способами: 

- Статический способ
- Динамический способ

1. __Статический способ__

В первом случае номера назначаются непосредственно разработчиком драйвера. Для этого необходимо вызвать функцию MKDEV, где числа будут заданы напрямую в параметрах:

```c
dev_t MKDEV(int major, int minor);
```

Для работы с данной функцией необходимо подключить следующий заголовочный файл:

```c
#include <linux/fs.h>
```

Далее возвращенное функцией значение необходимо передать в функцию register_chrdev_region. Ее входными аргументами являются возвращенное MKDEV значение, число создаваемых устройств и его имя:
```c
register_chrdev_region(dev_t dev, unsigned int x, char* name);
```

2. __Динамический способ__

В данном способе номера устройств выделяются системой из списка свободных, что позволяет избежать конфликтов драйверов, имеющих одинаковые номера. Для реализации метода необходимо воспользоваться следующей функцией:
```c
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```
Где dev - параметр, который при успешном завершении будет содержать первое число в выделенном диапазоне. 
firstminor – значение первого запрошенного младшего номера, обычно оно равно 0. 
count - общее количество непрерывных номеров запрашиваемых устройств
Для работы с данной функцией необходимо подключить следующий заголовочный файл:
```c
#include <linux/fs.h>
```
В данном примере старший и младший номера были выделены динамически
```c
dev_t dev = 0;
 
static int __init new_module_init(void)
{
...
alloc_chrdev_region(&dev, 0, 1, "Our_Device");
...
}
 
static int __init new_module_init(void)
{
...
unregister_chrdev_region (dev, 1);
...
}
```

### 8. В чем необходимость выполнения функции cdev_init?

Для того, чтобы связать символьное устройство с данными операциями, необходимо объявить элемент структуры cdev. Инициализация устройства осуществляется с помощью функции 
```c
void cdev_init(struct cdev *cdev, struct file_operations *fops);
```

### 9. Почему невозможно использовать функцию printf при написании модуля ядра?

В модулях ядра использование стандартной библиотеки невозможно, т.к. там нет доступа к стандартным библиотекам

### 10. В чем отличие функции printf от printk?

Одним из отличий printk от функции printf является возможность классифицировать выводимые сообщения в зависимости от их серьёзности, задавая сообщению уровень приоритета. Вызов «printk» направляет выводимую строку программе обработчику системного журнала, а не в текстовую консоль


